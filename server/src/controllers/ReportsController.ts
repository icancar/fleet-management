import { Request, Response, NextFunction } from 'express';
import { createError } from '../middleware/errorHandler';
import { ApiResponse } from '@fleet-management/shared';
import { UserRole } from '../models/User';
import { User } from '../models/User';
import { Vehicle } from '../models/Vehicle';
import { Device } from '../models/Device';
import { LocationLog } from '../models/LocationLog';
import { LocationDatabaseService } from '../services/LocationDatabaseService';
import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';

// Extend jsPDF type to include autoTable
declare module 'jspdf' {
  interface jsPDF {
    autoTable: (options: any) => jsPDF;
  }
}

export class ReportsController {
  
  /**
   * Test endpoint to check if reports controller is working
   */
  testReports = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const response: ApiResponse<any> = {
        success: true,
        data: { message: 'Reports controller is working' },
        message: 'Test successful'
      };
      res.json(response);
    } catch (error) {
      next(error);
    }
  };

  /**
   * Test PDF generation with minimal data
   */
  testPDF = async (req: Request, res: Response, next: NextFunction) => {
    try {
      console.log('ðŸ“Š Testing simple PDF generation...');
      
      // Create a very simple PDF first
      const doc = new jsPDF();
      doc.setFontSize(20);
      doc.text('Test PDF Report', 20, 20);
      doc.setFontSize(12);
      doc.text('This is a test PDF generated by the server.', 20, 40);
      doc.text(`Generated at: ${new Date().toLocaleString()}`, 20, 60);
      
      console.log('ðŸ“Š Converting simple PDF to buffer...');
      const pdfOutput = doc.output('arraybuffer');
      console.log('ðŸ“Š PDF output type:', typeof pdfOutput, 'length:', pdfOutput.byteLength);
      const buffer = Buffer.from(pdfOutput);
      console.log('ðŸ“Š Buffer created, size:', buffer.length);
      
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', 'attachment; filename="simple-test.pdf"');
      res.send(buffer);
    } catch (error) {
      console.error('ðŸ“Š Error in simple test PDF generation:', error);
      next(error);
    }
  };

  /**
   * Generate mileage report for selected drivers and date range
   */
  generateMileageReport = async (req: Request, res: Response, next: NextFunction) => {
    try {
      console.log('ðŸ“Š Generating mileage report...');
      const currentUser = (req as any).user;
      const { 
        startDate, 
        endDate, 
        reportType, 
        driverIds = [], 
        format = 'json' 
      } = req.body;

      console.log('ðŸ“Š Report request:', { startDate, endDate, reportType, driverIds, format, userRole: currentUser.role });

      // Validate required fields
      if (!startDate || !endDate || !reportType) {
        return res.status(400).json({
          success: false,
          message: 'Start date, end date, and report type are required'
        });
      }

      // Parse dates and ensure proper timezone handling
      const start = new Date(startDate + 'T00:00:00.000Z'); // Start of day in UTC
      const end = new Date(endDate + 'T23:59:59.999Z'); // End of day in UTC
      
      console.log(`ðŸ“Š Parsed dates - Start: ${start.toISOString()}, End: ${end.toISOString()}`);
      
      if (isNaN(start.getTime()) || isNaN(end.getTime())) {
        return res.status(400).json({
          success: false,
          message: 'Invalid date format'
        });
      }

      // Get allowed driver IDs based on user role
      let allowedDriverIds: string[] = [];
      
      switch (currentUser.role) {
        case UserRole.ADMIN:
          // Admin can see all drivers in their company
          if (driverIds.length === 0) {
            // Get all drivers in company
            const allDrivers = await User.find({ 
              companyId: currentUser.companyId,
              role: UserRole.DRIVER,
              isActive: true 
            });
            allowedDriverIds = allDrivers.map(driver => (driver._id as any).toString());
          } else {
            // Validate that requested drivers belong to their company
            const requestedDrivers = await User.find({
              _id: { $in: driverIds },
              companyId: currentUser.companyId,
              role: UserRole.DRIVER,
              isActive: true
            });
            allowedDriverIds = requestedDrivers.map(driver => (driver._id as any).toString());
          }
          break;

        case UserRole.MANAGER:
          // Manager can only see drivers they manage
          if (driverIds.length === 0) {
            // Get all drivers they manage
            const managedDrivers = await User.find({ 
              managerId: currentUser._id,
              role: UserRole.DRIVER,
              isActive: true 
            });
            allowedDriverIds = managedDrivers.map(driver => (driver._id as any).toString());
          } else {
            // Validate that requested drivers are managed by them
            const requestedDrivers = await User.find({
              _id: { $in: driverIds },
              managerId: currentUser._id,
              role: UserRole.DRIVER,
              isActive: true
            });
            allowedDriverIds = requestedDrivers.map(driver => (driver._id as any).toString());
          }
          break;

        case UserRole.DRIVER:
          // Driver can only see their own data
          allowedDriverIds = [currentUser._id];
          break;

        default:
          return res.status(403).json({
            success: false,
            message: 'Insufficient permissions to generate reports'
          });
      }

      if (allowedDriverIds.length === 0) {
        return res.status(404).json({
          success: false,
          message: 'No drivers found for the specified criteria'
        });
      }

      // Get driver details
      console.log('ðŸ“Š Fetching drivers for IDs:', allowedDriverIds);
      const drivers = await User.find({ _id: { $in: allowedDriverIds } }).lean();
      console.log('ðŸ“Š Found drivers:', drivers.length);

      // Get vehicles assigned to these drivers
      console.log('ðŸ“Š Fetching vehicles for driver IDs:', allowedDriverIds);
      const vehicles = await Vehicle.find({ 
        driverId: { $in: allowedDriverIds },
        status: 'active'
      }).lean();
      console.log('ðŸ“Š Found vehicles:', vehicles.length);

      // Create a map of driverId to vehicle for quick lookup
      const driverVehicleMap = new Map();
      vehicles.forEach(vehicle => {
        if (vehicle.driverId) {
          driverVehicleMap.set(vehicle.driverId.toString(), vehicle);
        }
      });

      // Get devices for these drivers
      console.log('ðŸ“Š Fetching devices for user IDs:', allowedDriverIds);
      const devices = await Device.find({ 
        userId: { $in: allowedDriverIds },
        isActive: true
      }).lean();
      console.log('ðŸ“Š Found devices:', devices.length);

      // Create a map of userId to deviceId
      const userDeviceMap = new Map();
      devices.forEach(device => {
        if (device.userId) {
          userDeviceMap.set(device.userId, device.deviceId);
        }
      });
      console.log('ðŸ“Š User device map:', Object.fromEntries(userDeviceMap));

      // Generate report data for each driver
      const reportData = [];
      
      try {
        for (const driver of drivers) {
        const driverId = driver._id.toString();
        const deviceId = userDeviceMap.get(driverId);
        const vehicle = driverVehicleMap.get(driverId);

        if (!deviceId) {
          // Driver has no device, skip or add with zero mileage
          reportData.push({
            driverId: driverId,
            driverName: `${driver.firstName} ${driver.lastName}`,
            driverEmail: driver.email,
            vehicle: vehicle ? {
              licensePlate: vehicle.licensePlate,
              make: vehicle.make,
              model: vehicle.model,
              year: vehicle.year,
              vin: vehicle.vin,
              odometer: vehicle.odometer
            } : null,
            totalMileage: 0,
            averageSpeed: 0,
            maxSpeed: 0,
            dailyBreakdown: [],
            monthlyBreakdown: []
          });
          continue;
        }

        // Get location data for the date range
        console.log(`ðŸ“Š Fetching location data for device ${deviceId} from ${start} to ${end}`);
        const locationData = await this.getLocationDataForDateRange(deviceId, start, end);
        console.log(`ðŸ“Š Found ${locationData.length} location records`);
        
        // Debug: Log first few location records
        if (locationData.length > 0) {
          console.log(`ðŸ“Š Sample location data:`, locationData.slice(0, 3).map(loc => ({
            timestamp: loc.timestamp,
            latitude: loc.latitude,
            longitude: loc.longitude,
            speed: loc.speed
          })));
        }
        
        // Calculate mileage and trip statistics
        const stats = this.calculateMileageStats(locationData, start, end, reportType);
        console.log(`ðŸ“Š Calculated stats for ${driver.firstName} ${driver.lastName}:`, stats);

        reportData.push({
          driverId: driverId,
          driverName: `${driver.firstName} ${driver.lastName}`,
          driverEmail: driver.email,
          vehicle: vehicle ? {
            licensePlate: vehicle.licensePlate,
            make: vehicle.make,
            model: vehicle.model,
            year: vehicle.year,
            vin: vehicle.vin,
            odometer: vehicle.odometer
          } : null,
          totalMileage: stats.totalMileage,
          averageSpeed: stats.averageSpeed,
          maxSpeed: stats.maxSpeed,
          dailyBreakdown: stats.dailyBreakdown,
          monthlyBreakdown: stats.monthlyBreakdown
        });
      }
      } catch (driverError) {
        console.error('ðŸ“Š Error processing drivers:', driverError);
        throw driverError;
      }

      // Calculate summary statistics
      const summary = {
        totalDrivers: reportData.length,
        totalMileage: reportData.reduce((sum, driver) => sum + driver.totalMileage, 0),
        averageMileagePerDriver: reportData.length > 0 
          ? reportData.reduce((sum, driver) => sum + driver.totalMileage, 0) / reportData.length 
          : 0
      };

      const report = {
        reportType,
        startDate: start.toISOString(),
        endDate: end.toISOString(),
        generatedAt: new Date().toISOString(),
        generatedBy: {
          userId: currentUser._id,
          name: `${currentUser.firstName} ${currentUser.lastName}`,
          role: currentUser.role
        },
        summary,
        drivers: reportData
      };

      if (format === 'pdf') {
        try {
          console.log('ðŸ“Š Generating PDF report...');
          // Generate PDF
          const pdfBuffer = await this.generatePDFReport(report, reportType);
          console.log('ðŸ“Š PDF generated successfully, size:', pdfBuffer.length);
          
          res.setHeader('Content-Type', 'application/pdf');
          res.setHeader('Content-Disposition', `attachment; filename="mileage-report-${reportType}-${startDate}-${endDate}.pdf"`);
          res.send(pdfBuffer);
        } catch (pdfError) {
          console.error('ðŸ“Š Error generating PDF:', pdfError);
          return res.status(500).json({
            success: false,
            message: 'Failed to generate PDF report',
            error: pdfError instanceof Error ? pdfError.message : 'Unknown error'
          });
        }
      } else {
        // Return JSON
        const response: ApiResponse<any> = {
          success: true,
          data: report,
          message: 'Mileage report generated successfully'
        };
        res.json(response);
      }

    } catch (error) {
      console.error('ðŸ“Š Error in generateMileageReport:', error);
      next(error);
    }
  };

  /**
   * Get available drivers for the current user
   */
  getAvailableDrivers = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const currentUser = (req as any).user;
      let drivers = [];

      switch (currentUser.role) {
        case UserRole.ADMIN:
          // Admin can see all drivers in their company
          drivers = await User.find({ 
            companyId: currentUser.companyId,
            role: UserRole.DRIVER,
            isActive: true 
          }).select('_id firstName lastName email').lean();
          break;

        case UserRole.MANAGER:
          // Manager can see drivers they manage
          drivers = await User.find({ 
            managerId: currentUser._id,
            role: UserRole.DRIVER,
            isActive: true 
          }).select('_id firstName lastName email').lean();
          break;

        case UserRole.DRIVER:
          // Driver can only see themselves
          drivers = [{
            _id: currentUser._id,
            firstName: currentUser.firstName,
            lastName: currentUser.lastName,
            email: currentUser.email
          }];
          break;

        default:
          return res.status(403).json({
            success: false,
            message: 'Insufficient permissions'
          });
      }

      const response: ApiResponse<any> = {
        success: true,
        data: drivers,
        message: 'Available drivers retrieved successfully'
      };

      res.json(response);
    } catch (error) {
      next(error);
    }
  };

  /**
   * Get location data for a specific date range
   */
  private async getLocationDataForDateRange(deviceId: string, startDate: Date, endDate: Date) {
    console.log(`ðŸ“Š Querying LocationLog for device ${deviceId} between ${startDate.toISOString()} and ${endDate.toISOString()}`);
    
    // First, let's check if there are ANY location logs for this device
    const totalLogs = await LocationLog.countDocuments({ deviceId: deviceId });
    console.log(`ðŸ“Š Total location logs for device ${deviceId}: ${totalLogs}`);
    
    if (totalLogs > 0) {
      // Get a sample of recent logs to see the data structure
      const sampleLogs = await LocationLog.find({ deviceId: deviceId })
        .sort({ timestamp: -1 })
        .limit(3)
        .lean();
      console.log(`ðŸ“Š Sample location logs:`, sampleLogs.map(log => ({
        timestamp: log.timestamp,
        latitude: log.latitude,
        longitude: log.longitude,
        speed: log.speed
      })));
    }
    
    const locationData = await LocationLog.find({
      deviceId: deviceId,
      timestamp: {
        $gte: startDate,
        $lte: endDate
      }
    }).sort({ timestamp: 1 }).lean();

    console.log(`ðŸ“Š Found ${locationData.length} location records in date range`);
    return locationData;
  }

  /**
   * Calculate mileage statistics from location data
   */
  private calculateMileageStats(locationData: any[], startDate: Date, endDate: Date, reportType: string) {
    if (locationData.length === 0) {
      return {
        totalMileage: 0,
        averageSpeed: 0,
        maxSpeed: 0,
        dailyBreakdown: [],
        monthlyBreakdown: []
      };
    }

    // Group data based on report type
    let groupedData: Map<string, any[]>;
    
    if (reportType === 'yearly') {
      // Group by month for yearly reports
      groupedData = new Map();
      const currentDate = new Date(startDate);
      
      while (currentDate <= endDate) {
        const monthKey = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}`;
        if (!groupedData.has(monthKey)) {
          groupedData.set(monthKey, []);
        }
        currentDate.setMonth(currentDate.getMonth() + 1);
      }
    } else {
      // Group by day for daily and weekly reports
      groupedData = new Map();
      const currentDate = new Date(startDate);
      
      while (currentDate <= endDate) {
        const dateKey = currentDate.toISOString().split('T')[0];
        groupedData.set(dateKey, []);
        currentDate.setDate(currentDate.getDate() + 1);
      }
    }
    
    console.log(`ðŸ“Š Created ${groupedData.size} time periods for grouping`);
    console.log(`ðŸ“Š Time periods:`, Array.from(groupedData.keys()));

    // Group location data
    let groupedCount = 0;
    locationData.forEach(location => {
      const locationDate = new Date(location.timestamp);
      
      if (reportType === 'yearly') {
        const monthKey = `${locationDate.getFullYear()}-${String(locationDate.getMonth() + 1).padStart(2, '0')}`;
        if (groupedData.has(monthKey)) {
          groupedData.get(monthKey)!.push(location);
          groupedCount++;
        }
      } else {
        const dateKey = locationDate.toISOString().split('T')[0];
        if (groupedData.has(dateKey)) {
          groupedData.get(dateKey)!.push(location);
          groupedCount++;
        }
      }
    });
    
    console.log(`ðŸ“Š Grouped ${groupedCount} location records into time periods`);
    console.log(`ðŸ“Š Records per period:`, Array.from(groupedData.entries()).map(([key, data]) => `${key}: ${data.length}`));

    // Calculate breakdown statistics
    const dailyBreakdown = [];
    const monthlyBreakdown = [];
    let totalMileage = 0;
    let allSpeeds = [];

    for (const [periodKey, periodData] of groupedData) {
      if (periodData.length === 0) {
        const breakdownItem = {
          period: periodKey,
          mileage: 0,
          averageSpeed: 0,
          maxSpeed: 0
        };
        
        if (reportType === 'yearly') {
          monthlyBreakdown.push(breakdownItem);
        } else {
          dailyBreakdown.push(breakdownItem);
        }
        continue;
      }

      // Calculate distance for the period
      let periodMileage = 0;
      console.log(`ðŸ“Š Calculating mileage for period ${periodKey} with ${periodData.length} points`);
      
      for (let i = 1; i < periodData.length; i++) {
        const prev = periodData[i - 1];
        const curr = periodData[i];
        const distance = this.calculateDistance(
          prev.latitude, prev.longitude,
          curr.latitude, curr.longitude
        );
        periodMileage += distance;
        
        if (i <= 3) { // Log first few calculations
          console.log(`ðŸ“Š Distance ${i}: (${prev.latitude}, ${prev.longitude}) -> (${curr.latitude}, ${curr.longitude}) = ${distance.toFixed(4)} km`);
        }
      }
      
      console.log(`ðŸ“Š Total mileage for period ${periodKey}: ${periodMileage.toFixed(4)} km`);

      // Calculate speeds
      const speeds = periodData.map((loc: any) => loc.speed || 0).filter((speed: number) => speed > 0);
      const averageSpeed = speeds.length > 0 ? speeds.reduce((a: number, b: number) => a + b, 0) / speeds.length : 0;
      const maxSpeed = speeds.length > 0 ? Math.max(...speeds) : 0;

      const breakdownItem = {
        period: periodKey,
        mileage: Math.round(periodMileage * 100) / 100, // Round to 2 decimal places
        averageSpeed: Math.round(averageSpeed * 100) / 100,
        maxSpeed: Math.round(maxSpeed * 100) / 100
      };

      if (reportType === 'yearly') {
        monthlyBreakdown.push(breakdownItem);
      } else {
        dailyBreakdown.push(breakdownItem);
      }

      totalMileage += periodMileage;
      allSpeeds.push(...speeds);
    }

    const overallAverageSpeed = allSpeeds.length > 0 
      ? allSpeeds.reduce((a, b) => a + b, 0) / allSpeeds.length 
      : 0;
    const overallMaxSpeed = allSpeeds.length > 0 ? Math.max(...allSpeeds) : 0;

    return {
      totalMileage: Math.round(totalMileage * 100) / 100,
      averageSpeed: Math.round(overallAverageSpeed * 100) / 100,
      maxSpeed: Math.round(overallMaxSpeed * 100) / 100,
      dailyBreakdown,
      monthlyBreakdown
    };
  }

  /**
   * Calculate distance between two coordinates using Haversine formula
   */
  private calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {
    const R = 6371; // Earth's radius in kilometers
    const dLat = this.toRadians(lat2 - lat1);
    const dLon = this.toRadians(lon2 - lon1);
    const a = 
      Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(this.toRadians(lat1)) * Math.cos(this.toRadians(lat2)) * 
      Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }

  /**
   * Convert degrees to radians
   */
  private toRadians(degrees: number): number {
    return degrees * (Math.PI / 180);
  }

  /**
   * Format month string for PDF display
   */
  private formatMonthForPDF(monthString: string): string {
    const [year, month] = monthString.split('-');
    const monthNames = [
      'January', 'February', 'March', 'April', 'May', 'June',
      'July', 'August', 'September', 'October', 'November', 'December'
    ];
    return `${monthNames[parseInt(month) - 1]} ${year}`;
  }


  /**
   * Generate PDF report
   */
  private async generatePDFReport(report: any, reportType: string): Promise<Buffer> {
    try {
      console.log('ðŸ“Š Creating new PDF document...');
      const doc = new jsPDF();
    
      // Add title
      doc.setFontSize(24);
      doc.setTextColor(31, 41, 55); // gray-900
      doc.text('Mileage Report', 20, 25);
      
      // Add report details in a styled box
      doc.setFillColor(249, 250, 251); // gray-50
      doc.rect(15, 35, 180, 35, 'F');
      doc.setDrawColor(229, 231, 235); // gray-200
      doc.rect(15, 35, 180, 35, 'S');
      
      doc.setFontSize(10);
      doc.setTextColor(75, 85, 99); // gray-600
      doc.text(`Report Type: ${report.reportType}`, 20, 45);
      doc.text(`Period: ${new Date(report.startDate).toLocaleDateString()} - ${new Date(report.endDate).toLocaleDateString()}`, 20, 52);
      doc.text(`Generated: ${new Date(report.generatedAt).toLocaleString()}`, 20, 59);
      doc.text(`Generated By: ${report.generatedBy.name} (${report.generatedBy.role})`, 20, 66);

      // Add summary cards (matching web UI)
      doc.setFontSize(16);
      doc.setTextColor(31, 41, 55); // gray-900
      doc.text('Summary', 20, 85);
      
      // Summary cards
      const cardWidth = 42;
      const cardHeight = 25;
      const cardSpacing = 5;
      const startX = 20;
      const startY = 95;
      
      // Total Drivers card
      doc.setFillColor(239, 246, 255); // blue-50
      doc.rect(startX, startY, cardWidth, cardHeight, 'F');
      doc.setDrawColor(191, 219, 254); // blue-200
      doc.rect(startX, startY, cardWidth, cardHeight, 'S');
      
      doc.setFontSize(8);
      doc.setTextColor(37, 99, 235); // blue-600
      doc.text('Total Drivers', startX + 2, startY + 8);
      doc.setFontSize(16);
      doc.setTextColor(30, 64, 175); // blue-900
      doc.text(report.summary.totalDrivers.toString(), startX + 2, startY + 18);
      
      // Total Mileage card
      doc.setFillColor(240, 253, 244); // green-50
      doc.rect(startX + cardWidth + cardSpacing, startY, cardWidth, cardHeight, 'F');
      doc.setDrawColor(187, 247, 208); // green-200
      doc.rect(startX + cardWidth + cardSpacing, startY, cardWidth, cardHeight, 'S');
      
      doc.setFontSize(8);
      doc.setTextColor(34, 197, 94); // green-600
      doc.text('Total Mileage', startX + cardWidth + cardSpacing + 2, startY + 8);
      doc.setFontSize(16);
      doc.setTextColor(20, 83, 45); // green-900
      doc.text(`${report.summary.totalMileage.toFixed(2)} km`, startX + cardWidth + cardSpacing + 2, startY + 18);
      
      // Average Mileage card
      doc.setFillColor(250, 245, 255); // purple-50
      doc.rect(startX + (cardWidth + cardSpacing) * 2, startY, cardWidth, cardHeight, 'F');
      doc.setDrawColor(221, 214, 254); // purple-200
      doc.rect(startX + (cardWidth + cardSpacing) * 2, startY, cardWidth, cardHeight, 'S');
      
      doc.setFontSize(8);
      doc.setTextColor(147, 51, 234); // purple-600
      doc.text('Avg Mileage/Driver', startX + (cardWidth + cardSpacing) * 2 + 2, startY + 8);
      doc.setFontSize(16);
      doc.setTextColor(88, 28, 135); // purple-900
      doc.text(`${report.summary.averageMileagePerDriver.toFixed(2)} km`, startX + (cardWidth + cardSpacing) * 2 + 2, startY + 18);

      // Add new page for drivers section
      if (report.drivers.length > 0) {
        doc.addPage();
      }

      // Add driver details section - each driver on a separate page
      for (let driverIndex = 0; driverIndex < report.drivers.length; driverIndex++) {
        const driver = report.drivers[driverIndex];
        
        // Add new page for each driver (except the first one)
        if (driverIndex > 0) {
          doc.addPage();
        }
        
        let yPosition = 20;

        // Add "Driver Details" header for the first driver
        if (driverIndex === 0) {
          doc.setFontSize(18);
          doc.setTextColor(31, 41, 55); // gray-900
          doc.text('Driver Details', 20, yPosition);
          yPosition += 15;
        }

        // Driver header section
        doc.setFontSize(16);
        doc.setTextColor(31, 41, 55); // gray-900
        doc.text(driver.driverName, 20, yPosition);
        doc.setFontSize(12);
        doc.setTextColor(75, 85, 99); // gray-600
        doc.text(driver.driverEmail, 20, yPosition + 8);
        
        // Total mileage (prominent display)
        doc.setFontSize(20);
        doc.setTextColor(37, 99, 235); // blue-600
        doc.text(`${driver.totalMileage.toFixed(2)} km`, 150, yPosition);
        doc.setFontSize(10);
        doc.setTextColor(75, 85, 99); // gray-600
        doc.text('Total Mileage', 150, yPosition + 8);
        
        yPosition += 25;

        // Vehicle info section
        if (driver.vehicle) {
          doc.setFillColor(249, 250, 251); // gray-50
          doc.rect(20, yPosition, 170, 18, 'F');
          doc.setDrawColor(229, 231, 235); // gray-200
          doc.rect(20, yPosition, 170, 18, 'S');
          
          doc.setFontSize(11);
          doc.setTextColor(31, 41, 55); // gray-900
          doc.text('Vehicle Information', 25, yPosition + 7);
          
          doc.setFontSize(9);
          doc.setTextColor(75, 85, 99); // gray-600
          doc.text(`${driver.vehicle.year} ${driver.vehicle.make} ${driver.vehicle.model}`, 25, yPosition + 13);
          doc.text(`Plate: ${driver.vehicle.licensePlate}`, 100, yPosition + 13);
          doc.text(`VIN: ${driver.vehicle.vin}`, 25, yPosition + 20);
          doc.text(`Odometer: ${driver.vehicle.odometer.toLocaleString()} km`, 100, yPosition + 20);
          
          yPosition += 22;
        } else {
          doc.setFillColor(254, 252, 232); // yellow-50
          doc.rect(20, yPosition, 170, 12, 'F');
          doc.setDrawColor(251, 191, 36); // yellow-400
          doc.rect(20, yPosition, 170, 12, 'S');
          
          doc.setFontSize(10);
          doc.setTextColor(146, 64, 14); // yellow-800
          doc.text('No vehicle assigned to this driver', 25, yPosition + 8);
          
          yPosition += 16;
        }

        // Statistics cards (matching web UI)
        const statCardWidth = 45;
        const statCardHeight = 18;
        const statSpacing = 5;
        const statStartX = 20;
        
        // Average Speed card
        doc.setFillColor(239, 246, 255); // blue-50
        doc.rect(statStartX, yPosition, statCardWidth, statCardHeight, 'F');
        doc.setDrawColor(191, 219, 254); // blue-200
        doc.rect(statStartX, yPosition, statCardWidth, statCardHeight, 'S');
        
        doc.setFontSize(13);
        doc.setTextColor(37, 99, 235); // blue-600
        doc.text(`${driver.averageSpeed.toFixed(1)} km/h`, statStartX + 3, yPosition + 7);
        doc.setFontSize(7);
        doc.setTextColor(75, 85, 99); // gray-600
        doc.text('Avg Speed', statStartX + 3, yPosition + 13);
        
        // Max Speed card
        doc.setFillColor(254, 242, 242); // red-50
        doc.rect(statStartX + statCardWidth + statSpacing, yPosition, statCardWidth, statCardHeight, 'F');
        doc.setDrawColor(252, 165, 165); // red-200
        doc.rect(statStartX + statCardWidth + statSpacing, yPosition, statCardWidth, statCardHeight, 'S');
        
        doc.setFontSize(13);
        doc.setTextColor(220, 38, 38); // red-600
        doc.text(`${driver.maxSpeed.toFixed(1)} km/h`, statStartX + statCardWidth + statSpacing + 3, yPosition + 7);
        doc.setFontSize(7);
        doc.setTextColor(75, 85, 99); // gray-600
        doc.text('Max Speed', statStartX + statCardWidth + statSpacing + 3, yPosition + 13);
        
        // Average Daily card
        const breakdownData = reportType === 'yearly' ? driver.monthlyBreakdown : driver.dailyBreakdown;
        const avgDaily = breakdownData.length > 0 
          ? (driver.totalMileage / breakdownData.length).toFixed(1)
          : 0;
        
        doc.setFillColor(250, 245, 255); // purple-50
        doc.rect(statStartX + (statCardWidth + statSpacing) * 2, yPosition, statCardWidth, statCardHeight, 'F');
        doc.setDrawColor(221, 214, 254); // purple-200
        doc.rect(statStartX + (statCardWidth + statSpacing) * 2, yPosition, statCardWidth, statCardHeight, 'S');
        
        doc.setFontSize(13);
        doc.setTextColor(147, 51, 234); // purple-600
        doc.text(`${avgDaily} km`, statStartX + (statCardWidth + statSpacing) * 2 + 3, yPosition + 7);
        doc.setFontSize(7);
        doc.setTextColor(75, 85, 99); // gray-600
        doc.text('Avg Daily', statStartX + (statCardWidth + statSpacing) * 2 + 3, yPosition + 13);
        
        yPosition += 22;

        // Breakdown table (only for Weekly and Yearly reports, not for Daily)
        if (reportType !== 'daily' && breakdownData.length > 0) {
          const breakdownTitle = reportType === 'yearly' ? 'Monthly Breakdown:' : 'Daily Breakdown:';
          
          doc.setFontSize(11);
          doc.setTextColor(31, 41, 55); // gray-900
          doc.text(breakdownTitle, 20, yPosition);
          yPosition += 6;

          // Table headers
          const tableData = [
            [reportType === 'yearly' ? 'Month' : 'Date', 'Mileage (km)', 'Avg Speed (km/h)', 'Max Speed (km/h)']
          ];

          // Add data rows
          breakdownData.forEach((period: any) => {
            const periodLabel = reportType === 'yearly' 
              ? this.formatMonthForPDF(period.period)
              : period.period;
            
            tableData.push([
              periodLabel,
              period.mileage.toString(),
              period.averageSpeed.toString(),
              period.maxSpeed.toString()
            ]);
          });

          // Add table with styling
          autoTable(doc, {
            startY: yPosition,
            head: [tableData[0]],
            body: tableData.slice(1),
            styles: { 
              fontSize: 9,
              cellPadding: 2,
              overflow: 'linebreak'
            },
            headStyles: { 
              fillColor: [249, 250, 251], // gray-50
              textColor: [75, 85, 99], // gray-600
              fontStyle: 'bold'
            },
            alternateRowStyles: {
              fillColor: [249, 250, 251] // gray-50
            },
            columnStyles: {
              0: { cellWidth: 30 }, // Date/Month
              1: { cellWidth: 35 }, // Mileage
              2: { cellWidth: 40 }, // Avg Speed
              3: { cellWidth: 40 }  // Max Speed
            }
          });

          yPosition = (doc as any).lastAutoTable.finalY + 10;
        }
      }

      console.log('ðŸ“Š Converting PDF to buffer...');
      const pdfOutput = doc.output('arraybuffer');
      console.log('ðŸ“Š PDF output type:', typeof pdfOutput, 'length:', pdfOutput.byteLength);
      const buffer = Buffer.from(pdfOutput);
      console.log('ðŸ“Š Buffer created, size:', buffer.length);
      return buffer;
    } catch (error) {
      console.error('ðŸ“Š Error in generatePDFReport:', error);
      throw error;
    }
  }
}
